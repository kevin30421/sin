<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>傅立葉變換動畫產生器</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;700&display=swap');
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
            overflow: hidden; /* 防止滾動，全螢幕應用 */
        }
        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #38bdf8;
            margin-top: -6px;
            cursor: pointer;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #334155;
            border-radius: 2px;
        }
        .equation-input:focus {
            outline: none;
            border-color: #38bdf8;
            box-shadow: 0 0 0 2px rgba(56, 189, 248, 0.2);
        }
        /* 自定義滾動條 */
        .custom-scroll::-webkit-scrollbar {
            width: 6px;
        }
        .custom-scroll::-webkit-scrollbar-track {
            background: #1e293b;
        }
        .custom-scroll::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 3px;
        }
    </style>
</head>
<body class="flex h-screen w-screen">

    <!-- 左側控制面板 -->
    <div class="w-1/3 min-w-[320px] max-w-[400px] bg-slate-900 border-r border-slate-700 flex flex-col z-10 shadow-xl">
        <div class="p-5 border-b border-slate-700 bg-slate-800">
            <h1 class="text-2xl font-bold text-sky-400 mb-1"><i class="fa-solid fa-wave-square mr-2"></i>傅立葉動畫</h1>
            <p class="text-xs text-slate-400">輸入方程式，觀察頻率分解與重組</p>
        </div>

        <!-- 方程式列表 -->
        <div class="flex-1 overflow-y-auto p-4 custom-scroll" id="equation-list">
            <!-- 方程式項目將由 JS 動態生成 -->
        </div>

        <!-- 底部控制區 -->
        <div class="p-4 bg-slate-800 border-t border-slate-700 space-y-4">
            <button onclick="addEquation()" class="w-full py-2 bg-slate-700 hover:bg-slate-600 text-sky-300 rounded-md transition border border-dashed border-slate-500 hover:border-sky-400">
                <i class="fa-solid fa-plus mr-2"></i>新增方程式
            </button>
            
            <div class="space-y-2">
                <div class="flex justify-between text-sm">
                    <span class="text-slate-300">圓圈數量 (N): <span id="n-display" class="font-mono text-sky-400">5</span></span>
                </div>
                <input type="range" id="slider-n" min="1" max="100" value="5" class="w-full">
            </div>

            <div class="space-y-2">
                 <div class="flex justify-between text-sm">
                    <span class="text-slate-300">動畫速度</span>
                </div>
                <input type="range" id="slider-speed" min="0.1" max="5" step="0.1" value="1" class="w-full">
            </div>
            
            <div class="pt-2 text-xs text-slate-500 font-mono">
                可用變數: t, PI<br>
                函數: sin, cos, tan, abs, pow, sqrt...<br>
                範例: sign(sin(t)) (方波)
            </div>
        </div>
    </div>

    <!-- 右側畫布 -->
    <div class="flex-1 relative bg-slate-950 overflow-hidden" id="canvas-wrapper">
        <canvas id="mainCanvas"></canvas>
        
        <!-- 浮動提示 -->
        <div class="absolute top-4 right-4 bg-black/60 backdrop-blur-sm px-4 py-2 rounded-full text-xs text-white border border-white/10 pointer-events-none">
            <i class="fa-solid fa-circle-nodes mr-2 text-sky-400"></i>白色線條 = 傅立葉級數近似值
        </div>
    </div>

    <script>
        // --- 數學核心工具 ---

        // 複數類別
        class Complex {
            constructor(a, b) {
                this.re = a;
                this.im = b;
            }
            add(c) { return new Complex(this.re + c.re, this.im + c.im); }
            mult(c) { return new Complex(this.re * c.re - this.im * c.im, this.re * c.im + this.im * c.re); }
        }

        // 離散傅立葉變換 (DFT)
        // x: 輸入的訊號樣本陣列 (複數或實數)
        function dft(x) {
            const X = [];
            const N = x.length;
            for (let k = 0; k < N; k++) {
                let sum = new Complex(0, 0);
                for (let n = 0; n < N; n++) {
                    const phi = (2 * Math.PI * k * n) / N;
                    const c = new Complex(Math.cos(phi), -Math.sin(phi));
                    sum = sum.add(x[n].mult(c));
                }
                sum.re = sum.re / N;
                sum.im = sum.im / N;

                let freq = k;
                let amp = Math.sqrt(sum.re * sum.re + sum.im * sum.im);
                let phase = Math.atan2(sum.im, sum.re);

                X[k] = { re: sum.re, im: sum.im, freq, amp, phase };
            }
            return X;
        }

        // --- 應用程式邏輯 ---

        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const listContainer = document.getElementById('equation-list');
        const sliderN = document.getElementById('slider-n');
        const nDisplay = document.getElementById('n-display');
        const sliderSpeed = document.getElementById('slider-speed');

        let time = 0;
        let path = []; // 繪製波形的軌跡
        let fourierData = []; // 計算出的傅立葉係數
        let equations = [
            { id: 1, text: "4 * sin(t) / PI + 4 * sin(3*t) / (3*PI)", active: true, color: '#38bdf8' }, // 方波的前兩項
            { id: 2, text: "t % (2*PI) < PI ? 1 : -1", active: false, color: '#a855f7' } // 真正的方波
        ];
        let currentEquationId = 1;
        
        // 畫布尺寸設定
        function resize() {
            const wrapper = document.getElementById('canvas-wrapper');
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // 數學解析器 (將字串轉換為可執行函數)
        function evaluateMath(expression, tVal) {
            // 安全性處理：限制可用變數與函數
            try {
                // 將 t 替換為實際數值，將常見數學函數映射到 Math 物件
                // 為了效能，我們構造一個 Function
                // 把 Math 的屬性解構出來供直接使用
                const scope = Object.getOwnPropertyNames(Math).reduce((acc, key) => {
                    acc[key] = Math[key];
                    return acc;
                }, {});
                scope.t = tVal;
                
                // 處理特殊語法別名
                let safeExpr = expression
                    .replace(/\bsign\b/g, 'Math.sign')
                    .replace(/\bsin\b/g, 'Math.sin')
                    .replace(/\bcos\b/g, 'Math.cos')
                    .replace(/\btan\b/g, 'Math.tan')
                    .replace(/\babs\b/g, 'Math.abs')
                    .replace(/\bPI\b/g, 'Math.PI')
                    .replace(/\bsqrt\b/g, 'Math.sqrt')
                    .replace(/\bpow\b/g, 'Math.pow');

                // 建立執行函數
                const func = new Function(...Object.keys(scope), `return ${safeExpr};`);
                return func(...Object.values(scope));
            } catch (e) {
                return 0; // 解析失敗回傳 0
            }
        }

        // 計算目前選中方程式的 DFT
        function computeCurrentDFT() {
            const eq = equations.find(e => e.id === currentEquationId);
            if (!eq) return;

            const N_SAMPLES = 200; // 採樣解析度
            let signal = [];
            
            // 1. 採樣：對一個週期 (0 到 2PI) 進行採樣
            for (let i = 0; i < N_SAMPLES; i++) {
                let t = (2 * Math.PI * i) / N_SAMPLES;
                let val = evaluateMath(eq.text, t);
                
                // 限制數值避免爆炸
                if (isNaN(val) || !isFinite(val)) val = 0;
                if (val > 5) val = 5; 
                if (val < -5) val = -5;

                // 轉換為複數格式 (實部為值，虛部為0)
                // 放大一點以便在畫布上看清 (scale factor)
                signal.push(new Complex(val * 80, 0)); 
            }

            // 2. 計算 DFT
            const rawDft = dft(signal);

            // 3. 排序：將振幅大的圓圈排在前面 (視覺效果較好)
            // 略過第0項(直流分量)通常會讓動畫置中更容易，但這裡我們保留並稍後處理位置
            fourierData = rawDft.sort((a, b) => b.amp - a.amp);
            
            // 重置路徑
            path = [];
            time = 0;
        }

        // --- 繪圖循環 ---
        function draw() {
            // 背景清空
            ctx.fillStyle = '#020617';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const activeEq = equations.find(e => e.id === currentEquationId);
            if (!activeEq) {
                requestAnimationFrame(draw);
                return;
            }

            // 圓圈數量的限制 (由 Slider 控制)
            // 注意：因為 DFT 對稱性，實際有用的頻率只有一半左右，但我們全部畫出來比較保險
            let maxN = parseInt(sliderN.value);
            // DFT 回傳 N 個結果，我們只需要前 N 個最大的分量來近似
            let currentData = fourierData.slice(0, Math.min(maxN, fourierData.length));

            // 設定原點 (畫布左側中心)
            let vx = canvas.width * 0.25; 
            let vy = canvas.height / 2;

            // 1. 繪製 Epicycles (旋轉圓圈)
            for (let i = 0; i < currentData.length; i++) {
                let prevx = vx;
                let prevy = vy;

                let freq = currentData[i].freq;
                let radius = currentData[i].amp;
                let phase = currentData[i].phase;

                // 計算向量尖端位置: 角度 = freq * time + phase
                // time 是一個週期 0 -> 2PI
                let angle = freq * time + phase;

                vx += radius * Math.cos(angle);
                vy += radius * Math.sin(angle);

                // 畫圓
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.lineWidth = 1;
                ctx.arc(prevx, prevy, radius, 0, 2 * Math.PI);
                ctx.stroke();

                // 畫半徑向量
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.moveTo(prevx, prevy);
                ctx.lineTo(vx, vy);
                ctx.stroke();
                
                // 畫小圓點連接處
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(vx, vy, 2, 0, 2 * Math.PI);
                ctx.fill();
            }

            // 2. 繪製連接線到波形
            // 波形將在右側繪製，隨著時間向右移動
            // 這裡我們做一個 "示波器" 風格，波形向右平移
            
            // 將目前的 y 值存入路徑
            // 我們其實是在畫 y(t)，x軸是時間
            // 為了視覺效果，我們將生成的點 (vx, vy) 的 y 座標拿來畫波形
            
            // 這裡稍微 trick 一下：
            // 傅立葉動畫通常有兩種：
            // A. 畫圖形 (x,y) -> 需要兩個 DFT
            // B. 畫波形 (t, y) -> 圓圈在左，波形向右拉出
            // 這裡是 B 模式
            
            // 將最新的點加入路徑頭部
            path.unshift(vy);

            // 繪製連接線 (從最後一個圓圈到波形起點)
            const waveStartX = canvas.width * 0.55;
            ctx.beginPath();
            ctx.moveTo(vx, vy);
            ctx.lineTo(waveStartX, path[0]);
            ctx.strokeStyle = activeEq.color;
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]); // 重置虛線

            // 3. 繪製波形
            ctx.beginPath();
            ctx.lineWidth = 3;
            ctx.strokeStyle = activeEq.color;
            
            // 我們把 path 陣列畫出來，x 座標隨 index 增加
            for (let i = 0; i < path.length; i++) {
                // x 軸縮放，讓波形拉長一點
                let px = waveStartX + i * 1.5; 
                let py = path[i];
                
                // 如果超出畫布就停止繪製
                if (px > canvas.width) {
                    path.splice(i); // 移除過舊的數據以節省記憶體
                    break; 
                }
                
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // 4. 繪製原始函數的完美曲線 (作為背景參考)
            // 只有當使用者輸入的是單純的時間函數時才有意義
            // 這裡可以選擇性實作，目前省略以保持畫面清晰

            // 更新時間
            const dt = (2 * Math.PI) / fourierData.length; 
            time += dt * parseFloat(sliderSpeed.value);

            // 如果時間超過 2PI，重置 (雖然數學上週期函數會繼續，但為了數值穩定)
            if (time > 2 * Math.PI) {
                time = 0;
            }

            requestAnimationFrame(draw);
        }

        // --- UI 管理 ---

        function renderList() {
            listContainer.innerHTML = '';
            equations.forEach(eq => {
                const el = document.createElement('div');
                el.className = `p-3 mb-3 rounded-lg border cursor-pointer transition flex flex-col gap-2 ${
                    eq.active 
                    ? 'bg-slate-800 border-sky-500 shadow-[0_0_10px_rgba(56,189,248,0.3)]' 
                    : 'bg-slate-800/50 border-slate-700 hover:border-slate-600'
                }`;
                el.onclick = (e) => {
                    // 避免點擊輸入框或按鈕時觸發切換
                    if(e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON' || e.target.tagName === 'I') return;
                    setActive(eq.id);
                };

                // 標頭區：選取狀態圓點 與 刪除按鈕
                const header = document.createElement('div');
                header.className = "flex justify-between items-center";
                header.innerHTML = `
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full" style="background-color: ${eq.color}; box-shadow: 0 0 5px ${eq.color}"></div>
                        <span class="text-sm font-bold text-slate-300">方程式 ${eq.id}</span>
                        ${eq.active ? '<span class="text-[10px] bg-sky-900 text-sky-300 px-1.5 py-0.5 rounded">顯示中</span>' : ''}
                    </div>
                    ${equations.length > 1 ? `<button onclick="removeEquation(${eq.id})" class="text-slate-500 hover:text-red-400 transition"><i class="fa-solid fa-trash"></i></button>` : ''}
                `;

                // 輸入框
                const input = document.createElement('input');
                input.type = 'text';
                input.value = eq.text;
                input.className = "equation-input w-full bg-slate-900 text-slate-200 text-sm p-2 rounded border border-slate-700 font-mono";
                input.onchange = (e) => updateEquationText(eq.id, e.target.value);
                input.onkeydown = (e) => { e.stopPropagation(); }; // 防止干擾快捷鍵

                el.appendChild(header);
                el.appendChild(input);
                listContainer.appendChild(el);
            });
        }

        function setActive(id) {
            if (currentEquationId === id) return;
            equations.forEach(e => e.active = (e.id === id));
            currentEquationId = id;
            renderList();
            computeCurrentDFT(); // 重新計算
        }

        function addEquation() {
            const newId = equations.length > 0 ? Math.max(...equations.map(e => e.id)) + 1 : 1;
            // 隨機顏色
            const colors = ['#38bdf8', '#a855f7', '#f472b6', '#34d399', '#fbbf24', '#f87171'];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            
            equations.push({
                id: newId,
                text: "sin(t) + 0.5 * sin(3*t)", // 預設值
                active: false,
                color: randomColor
            });
            // 自動切換到新的
            setActive(newId);
        }

        function removeEquation(id) {
            equations = equations.filter(e => e.id !== id);
            if (currentEquationId === id && equations.length > 0) {
                setActive(equations[0].id);
            } else if (equations.length === 0) {
                // 至少保留一個
                addEquation();
            } else {
                renderList();
            }
        }

        function updateEquationText(id, newText) {
            const eq = equations.find(e => e.id === id);
            if (eq) {
                eq.text = newText;
                if (eq.active) computeCurrentDFT();
            }
        }

        // --- 事件監聽 ---
        
        sliderN.addEventListener('input', (e) => {
            nDisplay.innerText = e.target.value;
            // 不需要重新計算 DFT，只需要在 draw 裡面 slice 資料即可
        });

        // 初始化
        renderList();
        computeCurrentDFT();
        draw();

    </script>
</body>
</html>
